{% extends 'layout.html' %}

{% block body %}

<style>
    body {
        background-color: black;
        
    }
    canvas {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.text {
  color: white;
  font-weight: 600;
  font-size: 24px;
  position: absolute;
  top: 55%;
  left: 50%;
  transform: translate(-50%, -50%);
}
</style>
    <!-- breadcrumb-section -->
 <div class="breadcrumb-section breadcrumb-bg">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 offset-lg-2 text-center">
                <div class="breadcrumb-text">
                    <p>Quick and Responsive</p>
                    <h1>Result</h1>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- end breadcrumb section -->
    <div class="mt-150">
        <div class="container" >
            <div >
                <div class="col-sm-12" >
                    <canvas id="canvas" height="175" width="350" class="m-auto">
    
                    </canvas>
                    <p class="text">60 %</p>
                </div>
            </div>
            <br><br>
            
            
        </div>
    
    

		<div class="container" style="padding-top: 60px;padding-bottom: 30px;">
			<div class="row">
				<div class="col-lg-8 offset-lg-2 text-center">
					<div class="section-title">
						<h3>The <span class="orange-text">Result</span></h3>
						<p style="color: white;font-weight: bolder;">The article provided is {{ prediction }} percent accurate</p>
					</div>
				</div>
			</div>
			<div class="row">
                <div class="col-lg-8 offset-lg-2 text-center">
                  
                   <a class="btn  " style="color: white!important;background-color: #ac6718;" href="{{ url_for('project') }}" class="link-button" >Try Again</a> 
                 
                </div>
              </div>
		</div>
	</div>

    <script>
        // Assign the value from {{ prediction }} to a JavaScript variable
        let predictionValue = {{ prediction }};
        //Change this Value to set the percentage
        let totalRot = ((predictionValue / 100) * 180 * Math.PI) / 180;

        let rotation = 0;
        let doAnim = true;
        let canvas = null;
        let ctx = null;
        let text = document.querySelector(".text");
        canvas = document.getElementById("canvas");
        ctx = canvas.getContext("2d");
        setTimeout(requestAnimationFrame(animate), 1500);

        function calcPointsCirc(cx, cy, rad, dashLength) {
        var n = rad / dashLength,
            alpha = (Math.PI * 2) / n,
            pointObj = {},
            points = [],
            i = -1;

        while (i < n) {
            var theta = alpha * i,
            theta2 = alpha * (i + 1);

            points.push({
            x: Math.cos(theta) * rad + cx,
            y: Math.sin(theta) * rad + cy,
            ex: Math.cos(theta2) * rad + cx,
            ey: Math.sin(theta2) * rad + cy
            });
            i += 2;
        }
        return points;
        }
        function animate() {
        //Clearing animation on every iteration
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const center = {
            x: 175,
            y: 175
        };

        //main arc
        ctx.beginPath();
        ctx.strokeStyle = rotation >= 0.75 * Math.PI ? "#FF9421" : "#35FFFF";
        ctx.lineWidth = "3";
        let radius = 174;
        ctx.arc(center.x, center.y, radius, Math.PI, Math.PI + rotation);
        ctx.stroke();

        //Red Arc
        if (rotation <= 0.75 * Math.PI) {
            ctx.beginPath();
            ctx.strokeStyle = "#FF9421";
            ctx.lineWidth = "3";
            ctx.arc(center.x, center.y, radius, 1.75 * Math.PI, 0);
            ctx.stroke();
        }

        //functions to draw dotted lines
        const DrawDottedLine = (x1, y1, x2, y2, dotRadius, dotCount, dotColor) => {
            var dx = x2 - x1;
            var dy = y2 - y1;
            let slopeOfLine = dy / dx;
            var degOfLine =
            Math.atan(slopeOfLine) * (180 / Math.PI) > 0
                ? Math.atan(slopeOfLine) * (180 / Math.PI)
                : 180 + Math.atan(slopeOfLine) * (180 / Math.PI);
            var degOfNeedle = rotation * (180 / Math.PI);

            if (rotation >= 0.75 * Math.PI) {
            dotColor = degOfLine <= degOfNeedle ? "#FF9421" : "#f97272";
            } else {
            dotColor = degOfLine <= degOfNeedle ? dotColor : "#aad4d4";
            }
            var spaceX = dx / (dotCount - 1);
            var spaceY = dy / (dotCount - 1);
            var newX = x1;
            var newY = y1;
            for (var i = 0; i < dotCount; i++) {
            dotRadius = dotRadius >= 0.75 ? dotRadius - i * (0.5 / 15) : dotRadius;
            drawDot(newX, newY, dotRadius, `${dotColor}${100 - (i + 1)}`);
            newX += spaceX;
            newY += spaceY;
            }
        };
        const drawDot = (x, y, dotRadius, dotColor) => {
            ctx.beginPath();
            ctx.arc(x, y, dotRadius, 0, 2 * Math.PI, false);
            ctx.fillStyle = dotColor;
            ctx.fill();
        };
        let firstDottedLineDots = calcPointsCirc(center.x, center.y, 165, 1);
        for (let k = 0; k < firstDottedLineDots.length; k++) {
            let x = firstDottedLineDots[k].x;
            let y = firstDottedLineDots[k].y;
            DrawDottedLine(x, y, 175, 175, 1.75, 30, "#35FFFF");
        }

        //dummy circle to hide the line connecting to center
        ctx.beginPath();
        ctx.arc(center.x, center.y, 80, 2 * Math.PI, 0);
        ctx.fillStyle = "black";
        ctx.fill();

        //Speedometer triangle
        var x = -75,
            y = 0;
        ctx.save();
        ctx.beginPath();
        ctx.translate(175, 175);
        ctx.rotate(rotation);
        ctx.moveTo(x, y);
        ctx.lineTo(x + 10, y - 10);
        ctx.lineTo(x + 10, y + 10);
        ctx.closePath();
        ctx.fillStyle = rotation >= 0.75 * Math.PI ? "#FF9421" : "#35FFFF";
        ctx.fill();
        ctx.restore();
        if (rotation < totalRot) {
            rotation += (1 * Math.PI) / 180;
            if (rotation > totalRot) {
            rotation -= (1 * Math.PI) / 180;
            }
        }

        text.innerHTML = Math.round((rotation / Math.PI) * 100) + 0 + "%";
        requestAnimationFrame(animate);
        }

    </script>
{% endblock %}